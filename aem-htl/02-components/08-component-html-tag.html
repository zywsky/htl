<!--
  AEM 组件 HTML 标签配置: _cq_htmlTag 文件夹详解
  
  本文档详细分析 AEM 组件中的 _cq_htmlTag 文件夹及其配置，
  包括其结构、属性、使用场景和最佳实践，从基础到高级应用
-->

<!--
  _cq_htmlTag 文件夹概述
  =====================
  
  _cq_htmlTag 是 AEM 组件的 HTML 标签配置文件，定义了组件渲染时的 HTML 标签属性。
  它允许开发者自定义组件包装元素的 HTML 标签、类名、ID、属性等。
  
  文件夹位置: /apps/{project}/components/{component-name}/_cq_htmlTag/
  节点类型: nt:unstructured (默认)
  
  作用:
  - 自定义组件包装元素的 HTML 标签（div, section, article 等）
  - 设置 HTML 属性（id, class, data-* 等）
  - 控制组件的 HTML 输出结构
  - 提供语义化的 HTML 标记
-->

<!--
  0. 为什么需要 _cq_htmlTag？它的核心作用和价值
  ===========================================
  
  在理解 _cq_htmlTag 的具体语法之前，首先要明白一个核心问题：
  
  为什么 AEM 组件需要 _cq_htmlTag 文件夹？
  
  ===== 核心答案 =====
  
  _cq_htmlTag 文件夹定义了"组件的 HTML 包装元素"，它控制组件在页面中的 HTML 标签类型和属性。
  
  ===== 详细解释 =====
  
  1. 问题的本质
  
  在 AEM 中，每个组件都会被包装在一个 HTML 元素中。默认情况下，AEM 使用 <div> 标签：
  
  默认行为（没有 _cq_htmlTag 配置）:
  
  HTL 模板内容:
  <div class="hero-content">
      <h1>${properties.title}</h1>
      <p>${properties.description}</p>
  </div>
  
  实际输出到浏览器的 HTML:
  <div class="cmp cmp--hero myapp-components-hero">
      <div class="hero-content">
          <h1>Title</h1>
          <p>Description</p>
      </div>
  </div>
  
  说明:
  - AEM 自动添加了一个外层的 <div> 包装元素
  - 这个外层 <div> 包含 AEM 默认的类名（cmp, cmp--hero 等）
  - 组件模板的内容被包裹在这个外层 <div> 中
  
  2. 如果没有 _cq_htmlTag 会怎样？
  
  问题场景:
  
  ❌ 无法自定义 HTML 标签类型
     - 总是使用 <div> 标签
     - 无法使用语义化的标签（<section>, <article>, <nav> 等）
     - 不利于 SEO 和无障碍访问
  
  ❌ 无法统一设置组件级别的 CSS 类名
     - 只能在 HTL 模板中手动设置
     - 每个组件实例都需要重复设置
     - 难以统一管理样式类名
  
  ❌ 无法为组件添加全局属性
     - 无法统一设置 data-* 属性
     - 无法统一设置 ARIA 属性
     - 无法统一设置 ID 属性（如果需要在配置层面）
  
  ❌ HTML 结构不够语义化
     - 所有组件都使用 <div>，缺乏语义
     - 不利于搜索引擎理解内容结构
     - 不利于屏幕阅读器等辅助技术
  
  3. _cq_htmlTag 具体是做什么的？
  
  _cq_htmlTag 文件夹的作用是"定义组件的 HTML 包装元素的配置"。
  
  具体来说，它配置了：
  
  a) HTML 标签类型（tagName）
     ────────────────────────
     
     配置内容: 使用什么 HTML 标签包装组件
     
     配置文件: _cq_htmlTag/.content.xml
     <jcr:root tagName="section"/>
     
     效果:
     - 将默认的 <div> 改为 <section>
     - 组件输出: <section class="...">...</section>
     - 提供语义化的 HTML 标记
     
     可选值:
     - div（默认）
     - section, article, nav, header, footer, aside, main
     - 任何有效的 HTML5 标签
  
  b) CSS 类名（class）
     ────────────────
     
     配置内容: 组件包装元素的 CSS 类名
     
     配置文件: _cq_htmlTag/.content.xml
     <jcr:root tagName="section" class="hero-section"/>
     
     效果:
     - 为组件包装元素添加自定义 CSS 类名
     - 输出: <section class="hero-section cmp cmp--hero ...">
     - 可以与 AEM 默认类名共存
     - 统一管理组件级别的样式类名
     
     使用场景:
     - 为组件添加基础样式类
     - 实现主题和变体样式
     - 统一管理组件样式
  
  c) HTML 属性（id, data-*, aria-* 等）
     ─────────────────────────────────
     
     配置内容: 组件包装元素的其他 HTML 属性
     
     配置文件: _cq_htmlTag/.content.xml
     <jcr:root tagName="section"
               class="hero-section"
               id="main-hero"
               data-component="hero"
               role="banner"
               aria-label="Hero Section"/>
     
     效果:
     - 为组件包装元素添加各种 HTML 属性
     - 支持标准属性（id, class, lang 等）
     - 支持 data-* 自定义属性
     - 支持 ARIA 无障碍属性
     - 支持任何有效的 HTML 属性
  
  d) HTML 结构控制
     ─────────────
     
     配置内容: 控制组件在 DOM 中的 HTML 结构
     
     效果:
     - 定义组件的最外层 HTML 元素
     - 控制组件的 HTML 语义结构
     - 影响组件的 CSS 选择器和 JavaScript 选择器
     - 影响 SEO 和可访问性
  
  4. _cq_htmlTag 描述/配置了什么？
  
  具体配置内容:
  
  ┌─────────────────────────────────────────────────────────────┐
  │ _cq_htmlTag/.content.xml 配置文件描述的内容:               │
  ├─────────────────────────────────────────────────────────────┤
  │                                                             │
  │ 1. 标签类型（tagName）                                      │
  │    - 描述: 使用什么 HTML 标签包装组件                      │
  │    - 配置: tagName="section"                                │
  │    - 影响: 组件的 HTML 标签类型                             │
  │                                                             │
  │ 2. CSS 类名（class）                                       │
  │    - 描述: 组件包装元素的 CSS 类名                          │
  │    - 配置: class="hero-section"                             │
  │    - 影响: 组件的样式选择和样式应用                          │
  │                                                             │
  │ 3. ID 属性（id）                                           │
  │    - 描述: 组件包装元素的 ID（如果设置）                    │
  │    - 配置: id="hero-section"                                │
  │    - 影响: JavaScript 选择器和锚点链接                      │
  │                                                             │
  │ 4. Data 属性（data-*）                                     │
  │    - 描述: 自定义数据属性                                    │
  │    - 配置: data-component="hero"                            │
  │    - 影响: 前端框架集成和 JavaScript 数据访问               │
  │                                                             │
  │ 5. ARIA 属性（aria-*, role）                               │
  │    - 描述: 无障碍访问属性                                    │
  │    - 配置: role="banner", aria-label="Hero Section"        │
  │    - 影响: 屏幕阅读器和可访问性工具                          │
  │                                                             │
  │ 6. 其他 HTML 属性                                          │
  │    - 描述: 语言、标题等其他属性                              │
  │    - 配置: lang="en", title="Hero Section"                 │
  │    - 影响: 浏览器行为和辅助功能                              │
  │                                                             │
  └─────────────────────────────────────────────────────────────┘
  
  5. 完整的工作流程示例
  
  场景: 配置 Hero 组件的 HTML 标签
  
  步骤 1: 创建配置文件
  ──────────────────
  
  文件位置: /apps/myapp/components/hero/_cq_htmlTag/.content.xml
  
  配置文件内容:
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section"
            role="banner"
            aria-label="Hero Banner"
            data-component="hero"/>
  
  步骤 2: AEM 读取配置
  ──────────────────
  
  当组件被渲染时:
  - AEM 检查组件定义路径: /apps/myapp/components/hero
  - 查找 _cq_htmlTag 文件夹
  - 读取 .content.xml 配置文件
  - 解析配置属性（tagName, class, role 等）
  
  步骤 3: 应用配置
  ───────────────
  
  AEM 应用配置到组件包装元素:
  - 标签类型: <div> → <section>
  - CSS 类名: 添加 "hero-section"
  - ARIA 属性: 添加 role="banner" 和 aria-label
  - Data 属性: 添加 data-component="hero"
  
  步骤 4: 渲染组件
  ───────────────
  
  HTL 模板内容（hero.html）:
  <div class="hero-content">
      <h1>${properties.title}</h1>
      <p>${properties.description}</p>
  </div>
  
  最终输出到浏览器的 HTML:
  <section class="hero-section cmp cmp--hero myapp-components-hero"
           role="banner"
           aria-label="Hero Banner"
           data-component="hero"
           data-cq-editable="..."
           id="cq_id_1234567890">
      <div class="hero-content">
          <h1>Welcome to Our Site</h1>
          <p>This is the hero section</p>
      </div>
  </section>
  
  说明:
  - 外层使用 <section> 标签（来自配置的 tagName）
  - 类名包含 "hero-section"（来自配置的 class）
  - 还包含 AEM 默认类名（cmp, cmp--hero 等）
  - 包含配置的 ARIA 属性
  - 包含配置的 data 属性
  - 包含 AEM 自动添加的属性（data-cq-editable, id 等）
  - 组件模板的内容被包裹在这个包装元素中
  
  6. 对比：有配置 vs 没有配置
  
  ┌──────────────────────────────────────────────────────────────┐
  │ 场景 1: 没有 _cq_htmlTag 配置                                │
  ├──────────────────────────────────────────────────────────────┤
  │                                                              │
  │ HTL 模板:                                                    │
  │ <div class="hero-content">                                  │
  │     <h1>${properties.title}</h1>                            │
  │ </div>                                                       │
  │                                                              │
  │ 输出 HTML:                                                   │
  │ <div class="cmp cmp--hero myapp-components-hero">           │
  │     <div class="hero-content">                              │
  │         <h1>Title</h1>                                      │
  │     </div>                                                   │
  │ </div>                                                       │
  │                                                              │
  │ 特点:                                                        │
  │ - 使用默认 <div> 标签                                        │
  │ - 只有 AEM 默认类名                                          │
  │ - 无自定义属性                                               │
  │ - 缺乏语义化                                                 │
  │                                                              │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ 场景 2: 有 _cq_htmlTag 配置                                  │
  ├──────────────────────────────────────────────────────────────┤
  │                                                              │
  │ 配置: _cq_htmlTag/.content.xml                               │
  │ <jcr:root tagName="section"                                 │
  │           class="hero-section"                               │
  │           role="banner"/>                                    │
  │                                                              │
  │ HTL 模板（相同）:                                            │
  │ <div class="hero-content">                                  │
  │     <h1>${properties.title}</h1>                            │
  │ </div>                                                       │
  │                                                              │
  │ 输出 HTML:                                                   │
  │ <section class="hero-section cmp cmp--hero ..."             │
  │          role="banner">                                     │
  │     <div class="hero-content">                              │
  │         <h1>Title</h1>                                      │
  │     </div>                                                   │
  │ </section>                                                   │
  │                                                              │
  │ 特点:                                                        │
  │ - 使用语义化的 <section> 标签                                │
  │ - 有自定义类名 "hero-section"                                │
  │ - 有 ARIA 属性 role="banner"                                │
  │ - 语义化更好，有利于 SEO 和可访问性                          │
  │                                                              │
  └──────────────────────────────────────────────────────────────┘
  
  7. _cq_htmlTag 在整个组件系统中的地位
  
  AEM 组件生态系统:
  
  .content.xml          → 组件定义（组件是什么，有什么属性）
  component.html        → 渲染脚本（组件内部内容的 HTML 结构）
  _cq_htmlTag/          → HTML 包装配置（组件外层包装元素的配置）← 这就是它！
  _cq_dialog/           → 编辑对话框（用户如何配置组件）
  _cq_editConfig.xml    → 编辑配置（组件在编辑器中如何表现）
  _cq_template/         → 初始内容（首次创建时的默认值）
  
  _cq_htmlTag 的作用范围:
  
  ┌─────────────────────────────────────────────┐
  │ 组件包装元素（_cq_htmlTag 配置的范围）      │
  │ <section class="hero-section ...">         │ ← _cq_htmlTag 控制这里
  │                                             │
  │     ┌───────────────────────────────────┐  │
  │     │ 组件内容（HTL 模板控制的范围）    │  │
  │     │ <div class="hero-content">       │  │ ← hero.html 控制这里
  │     │     <h1>Title</h1>               │  │
  │     │     <p>Description</p>           │  │
  │     │ </div>                           │  │
  │     └───────────────────────────────────┘  │
  │                                             │
  │ </section>                                  │
  └─────────────────────────────────────────────┘
  
  8. 实际应用场景和价值
  
  场景 1: SEO 优化
  ──────────────
  
  需求: 使用语义化的 HTML 标签改善 SEO
  
  配置:
  <jcr:root tagName="article"
            itemscope=""
            itemtype="http://schema.org/Article"/>
  
  价值:
  ✅ 搜索引擎更容易理解内容结构
  ✅ 使用 Schema.org 微数据
  ✅ 改善搜索排名
  
  场景 2: 无障碍访问
  ────────────────
  
  需求: 改善屏幕阅读器支持
  
  配置:
  <jcr:root tagName="nav"
            role="navigation"
            aria-label="Main Navigation"/>
  
  价值:
  ✅ 屏幕阅读器能够识别导航区域
  ✅ 符合 WCAG 无障碍标准
  ✅ 改善残障用户的访问体验
  
  场景 3: 统一样式管理
  ──────────────────
  
  需求: 为组件统一添加基础样式类
  
  配置:
  <jcr:root tagName="section"
            class="hero-section"/>
  
  价值:
  ✅ 所有 Hero 组件实例都有统一的类名
  ✅ 统一管理组件样式
  ✅ 减少在 HTL 模板中重复设置类名
  
  场景 4: 前端框架集成
  ──────────────────
  
  需求: 为 React/Vue 等框架提供数据属性
  
  配置:
  <jcr:root tagName="div"
            data-component="hero"
            data-react-component="HeroComponent"/>
  
  价值:
  ✅ 前端框架可以识别组件
  ✅ 可以挂载前端框架组件
  ✅ 实现前后端分离架构
  
  场景 5: 主题和变体
  ────────────────
  
  需求: 支持不同的主题和变体样式
  
  配置（基础配置）:
  <jcr:root tagName="section"
            class="hero-section"
            data-theme="default"/>
  
  HTL 模板（动态变体）:
  <section data-sly-attribute.class="${'hero-section hero--' + properties.variant}"
           data-sly-attribute.data-theme="${properties.theme}">
      <!-- 内容 -->
  </section>
  
  价值:
  ✅ 基础样式类在配置中统一管理
  ✅ 动态变体类在 HTL 中灵活设置
  ✅ 两者结合使用
  
  9. _cq_htmlTag 的价值总结
  
  a) 语义化 HTML
     - 使用合适的 HTML5 标签
     - 改善内容结构
     - 有利于 SEO 和无障碍访问
  
  b) 统一管理
     - 统一设置组件级别的属性
     - 减少重复配置
     - 集中管理组件包装元素配置
  
  c) 灵活性
     - 支持自定义 HTML 标签
     - 支持各种 HTML 属性
     - 与 HTL 模板配合使用
  
  d) 可维护性
     - 配置与模板分离
     - 清晰的职责划分
     - 易于维护和更新
  
  e) 标准化
     - 遵循 HTML5 标准
     - 符合现代 Web 开发实践
     - 与 Core Components 保持一致
  
  10. 类比说明
  
  把组件比作一个礼物盒：
  
  - .content.xml = 礼物的"说明书"（定义这是什么）
  - component.html = 礼物的"内容"（实际的礼物）
  - _cq_htmlTag = 礼物的"包装盒"（外层的包装）
  
  没有 _cq_htmlTag:
  - 所有礼物都用相同的默认包装盒（<div>）
  - 无法根据礼物类型选择合适的包装盒
  - 包装盒上没有标签和说明
  
  有 _cq_htmlTag:
  - 可以为不同类型的礼物选择不同的包装盒（<section>, <article> 等）
  - 可以在包装盒上贴上标签和说明（class, data-*, aria-* 等）
  - 包装盒更加精美和有用（语义化、可访问性）
  
  11. 关键要点总结
  
  ✅ _cq_htmlTag 定义了组件的外层 HTML 包装元素
  ✅ 它配置了标签类型、CSS 类名、HTML 属性等
  ✅ 它影响组件的 HTML 输出结构
  ✅ 它提供语义化的 HTML 标记
  ✅ 它改善 SEO 和无障碍访问
  ✅ 它统一管理组件级别的 HTML 属性
  ✅ 它与 HTL 模板配合使用，分工明确
  ✅ 它是组件系统中不可或缺的一部分
-->

<!--
  1. 基本概念
  ==========
-->

<!--
  1.1 什么是 HTML 标签配置
  -----------------------
  
  HTML 标签配置定义了组件在页面中渲染时的包装元素。
  
  默认行为:
  - 如果没有配置，AEM 默认使用 <div> 标签包装组件
  - 组件会有默认的 class 和 data 属性
  
  配置后:
  - 可以自定义 HTML 标签类型
  - 可以添加自定义属性
  - 可以设置类名、ID 等
  
  使用场景:
  - 需要语义化 HTML（使用 section, article, nav 等）
  - 需要自定义 CSS 选择器
  - 需要设置特定的 HTML 属性
  - SEO 优化需求
-->

<!--
  1.2 模板文件结构
  ---------------
  
  _cq_htmlTag 文件夹的结构:
  
  /apps/myapp/components/hero/
    ├── .content.xml                    # 组件定义
    ├── hero.html                       # HTL 模板
    ├── _cq_dialog/                     # 编辑对话框
    ├── _cq_editConfig.xml              # 编辑配置
    └── _cq_htmlTag/                    # HTML 标签配置
        └── .content.xml                # HTML 标签配置定义
  
  注意:
  - _cq_htmlTag 本身是一个文件夹/节点
  - 其内容定义了组件包装元素的 HTML 属性
  - 配置会影响组件的最终 HTML 输出
-->

<!--
  1.3 HTML 标签配置工作原理
  -----------------------
  
  组件渲染流程:
  
  1. AEM 开始渲染组件
  2. 查找组件的 _cq_htmlTag 配置
  3. 如果存在，使用配置的 HTML 标签和属性
  4. 如果不存在，使用默认的 <div> 标签
  5. 渲染组件内容
  6. 输出最终的 HTML
  
  流程图:
  
  开始渲染 → 查找配置 → 应用标签和属性 → 渲染内容 → 输出 HTML
  
  关键点:
  - 配置应用于组件的包装元素
  - 不影响组件内部的内容结构
  - 只在组件级别生效
-->

<!--
  2. 基本配置
  ==========
-->

<!--
  2.1 最简单的配置
  --------------
-->

<!--
  最简单的 HTML 标签配置:
  
  /apps/myapp/components/hero/_cq_htmlTag/.content.xml
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="section"/>
  
  说明:
  - tagName="section": 将默认的 <div> 改为 <section>
  - 组件输出: <section class="...">...</section>
  - 其他属性使用默认值
-->

<!--
  2.2 自定义标签名称
  ----------------
-->

<!--
  示例: 使用不同的 HTML 标签
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="article"/>
  
  常用标签:
  - "section": 章节区域
  - "article": 文章内容
  - "nav": 导航区域
  - "header": 页头区域
  - "footer": 页脚区域
  - "aside": 侧边栏
  - "main": 主要内容区域
  - "div": 通用容器（默认）
  
  说明:
  - 可以使用任何有效的 HTML5 标签
  - 标签名不区分大小写（但推荐小写）
  - 使用语义化标签有助于 SEO 和可访问性
-->

<!--
  2.3 添加 CSS 类名
  ----------------
-->

<!--
  示例: 添加自定义类名
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section custom-class"/>
  
  说明:
  - class: CSS 类名，多个类名用空格分隔
  - 类名会添加到组件包装元素
  - AEM 默认类名也会保留（如组件路径类名）
  - 可以用于样式定制
-->

<!--
  2.4 设置 ID 属性
  ---------------
-->

<!--
  示例: 设置 ID 属性
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="section"
            id="hero-section"/>
  
  说明:
  - id: HTML ID 属性（全局唯一）
  - 注意: ID 在整个页面中必须唯一
  - 如果多个组件实例，可能需要动态 ID
  - 通常用于 JavaScript 选择器或锚点
-->

<!--
  2.5 组合配置
  ----------
-->

<!--
  示例: 组合多个属性
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section"
            id="hero"
            data-component="hero"
            data-variant="default"
            role="banner"/>
  
  说明:
  - 可以组合多个属性
  - 支持 HTML5 data-* 属性
  - 支持 ARIA 属性（role, aria-*）
  - 属性会全部应用到包装元素
-->

<!--
  3. 属性详解
  ==========
-->

<!--
  3.1 tagName 属性
  --------------
-->

<!--
  tagName
  - 类型: String
  - 必需: 否
  - 默认值: "div"
  - 说明: HTML 标签名称
  - 可选值: 任何有效的 HTML5 标签名
  - 常用值: div, section, article, nav, header, footer, aside, main
  
  示例:
  
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"/>
  
  输出:
  <section class="...">...</section>
  
  注意事项:
  - 标签名应该是有效的 HTML5 标签
  - 不区分大小写（推荐小写）
  - 不能使用自定义标签（除非在 HTML5 中定义）
-->

<!--
  3.2 class 属性
  ------------
-->

<!--
  class
  - 类型: String
  - 必需: 否
  - 说明: CSS 类名（多个类名用空格分隔）
  - 格式: "class1 class2 class3"
  
  示例:
  
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section theme-light"/>
  
  输出:
  <section class="hero-section theme-light ...">...</section>
  
  说明:
  - 多个类名用空格分隔
  - AEM 默认类名会自动添加（如组件路径类名）
  - 可以在 CSS 中使用这些类名进行样式定制
  - 类名可以用于 JavaScript 选择器
-->

<!--
  3.3 id 属性
  ----------
-->

<!--
  id
  - 类型: String
  - 必需: 否
  - 说明: HTML ID 属性（页面内唯一）
  - 限制: 在整个页面中必须唯一
  
  示例:
  
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            id="main-hero"/>
  
  输出:
  <section id="main-hero" class="...">...</section>
  
  注意事项:
  - ID 在整个页面中必须唯一
  - 如果组件有多个实例，静态 ID 会导致冲突
  - 建议使用动态 ID（在 HTL 模板中设置）
  - ID 常用于 JavaScript 选择器和锚点
-->

<!--
  3.4 data-* 属性
  -------------
-->

<!--
  data-* 属性
  - 类型: String
  - 必需: 否
  - 说明: HTML5 自定义数据属性
  - 格式: data-*="value"
  
  示例:
  
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            data-component="hero"
            data-variant="default"
            data-animation="fade-in"/>
  
  输出:
  <section data-component="hero" data-variant="default" data-animation="fade-in" class="...">...</section>
  
  说明:
  - data-* 属性用于存储自定义数据
  - 可以通过 JavaScript 访问: element.dataset.component
  - 常用于前端框架集成
  - 不会影响样式，但可以通过 CSS 属性选择器使用
-->

<!--
  3.5 ARIA 属性
  ------------
-->

<!--
  ARIA 属性（无障碍访问）
  - 类型: String
  - 必需: 否
  - 说明: 用于改善可访问性的属性
  - 常用属性: role, aria-label, aria-labelledby, aria-describedby 等
  
  示例:
  
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            role="banner"
            aria-label="Hero Section"
            aria-labelledby="hero-title"/>
  
  输出:
  <section role="banner" aria-label="Hero Section" aria-labelledby="hero-title" class="...">...</section>
  
  说明:
  - ARIA 属性用于改善可访问性
  - 有助于屏幕阅读器理解内容
  - 推荐在语义化标签不足时使用
  - 符合 WCAG 无障碍标准
-->

<!--
  3.6 其他 HTML 属性
  ----------------
-->

<!--
  其他常用属性:
  
  - lang: 语言代码
  - title: 工具提示文本
  - style: 内联样式（不推荐，建议使用 class）
  - hidden: 隐藏元素
  - tabindex: Tab 键顺序
  
  示例:
  
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            lang="en"
            title="Hero Section"
            tabindex="0"/>
  
  说明:
  - 可以设置任何有效的 HTML 属性
  - 但应该遵循最佳实践
  - 避免使用内联样式（style）
  - 使用语义化的方式（如用 class 代替 style）
-->

<!--
  4. 实际应用示例
  ==============
-->

<!--
  4.1 Hero 组件配置
  ----------------
-->

<!--
  Hero 组件 HTML 标签配置:
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section"
            role="banner"
            aria-label="Hero Banner"
            data-component="hero"/>
  
  输出 HTML:
  <section class="hero-section ..." role="banner" aria-label="Hero Banner" data-component="hero">
      <!-- 组件内容 -->
  </section>
  
  说明:
  - 使用语义化的 <section> 标签
  - 添加自定义类名用于样式
  - 使用 ARIA 属性改善可访问性
  - 添加 data 属性用于 JavaScript 选择
-->

<!--
  4.2 导航组件配置
  --------------
-->

<!--
  导航组件 HTML 标签配置:
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="nav"
            class="main-navigation"
            role="navigation"
            aria-label="Main Navigation"/>
  
  输出 HTML:
  <nav class="main-navigation ..." role="navigation" aria-label="Main Navigation">
      <!-- 导航内容 -->
  </nav>
  
  说明:
  - 使用 <nav> 语义化标签
  - 添加导航角色和标签
  - 符合 HTML5 语义化标准
-->

<!--
  4.3 文章组件配置
  --------------
-->

<!--
  文章组件 HTML 标签配置:
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="article"
            class="content-article"
            role="article"
            data-article-id="${properties.articleId}"/>
  
  输出 HTML:
  <article class="content-article ..." role="article" data-article-id="123">
      <!-- 文章内容 -->
  </article>
  
  注意:
  - data-article-id 使用表达式语法（如果支持）
  - 实际使用中，动态值通常在 HTL 模板中设置
-->

<!--
  4.4 容器组件配置
  --------------
-->

<!--
  容器组件 HTML 标签配置:
  
  <?xml version="1.0" encoding="UTF-8"?>
  <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0"
            xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
            jcr:primaryType="nt:unstructured"
            tagName="div"
            class="container-section"
            data-container-type="flex"/>
  
  输出 HTML:
  <div class="container-section ..." data-container-type="flex">
      <!-- 容器内容 -->
  </div>
  
  说明:
  - 容器组件通常使用 <div>
  - 添加容器类型标识
  - 使用 data 属性标记容器类型
-->

<!--
  5. 与 HTL 模板的集成
  ===================
-->

<!--
  5.1 默认行为
  -----------
  
  如果没有 _cq_htmlTag 配置:
  
  HTL 模板:
  <div class="component-content">
      <h1>${properties.title}</h1>
  </div>
  
  输出 HTML:
  <div class="cmp cmp--hero ...">
      <div class="component-content">
          <h1>Title</h1>
      </div>
  </div>
  
  说明:
  - AEM 默认使用 <div> 包装
  - 自动添加组件类名（cmp, cmp--hero 等）
  - 组件 ID 和 data 属性也会自动添加
-->

<!--
  5.2 使用配置后
  -------------
  
  如果有 _cq_htmlTag 配置:
  
  _cq_htmlTag/.content.xml:
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section"/>
  
  HTL 模板（相同）:
  <div class="component-content">
      <h1>${properties.title}</h1>
  </div>
  
  输出 HTML:
  <section class="hero-section cmp cmp--hero ...">
      <div class="component-content">
          <h1>Title</h1>
      </div>
  </section>
  
  说明:
  - 使用配置的 <section> 标签
  - 添加配置的类名
  - AEM 默认类名仍然保留
  - 组件内容结构不变
-->

<!--
  5.3 在 HTL 中覆盖属性
  -------------------
  
  HTL 模板可以覆盖 HTML 标签配置:
  
  hero.html:
  <section data-sly-attribute.class="${'custom-class ' + component.cssClassNames}"
           data-sly-attribute.id="${component.id}"
           data-sly-attribute.data-variant="${properties.variant}">
      <!-- 组件内容 -->
  </section>
  
  说明:
  - HTL 模板中的属性会覆盖配置
  - 但通常建议在配置中设置静态属性
  - 动态属性在 HTL 中设置
  - 两者可以结合使用
-->

<!--
  6. 动态属性
  ==========
-->

<!--
  6.1 在 HTL 中设置动态属性
  -----------------------
  
  虽然 _cq_htmlTag 配置是静态的，但可以在 HTL 模板中设置动态属性:
  
  hero.html:
  <section data-sly-attribute.id="${component.id}"
           data-sly-attribute.class="${'hero-' + properties.variant + ' ' + component.cssClassNames}"
           data-sly-attribute.data-variant="${properties.variant}"
           data-sly-attribute.data-page="${currentPage.path}">
      <h1>${properties.title}</h1>
  </section>
  
  说明:
  - component.id: 组件唯一 ID
  - component.cssClassNames: 组件 CSS 类名
  - 可以基于组件属性设置动态值
  - 结合配置和 HTL 实现灵活控制
-->

<!--
  6.2 使用 Sling Model 提供属性
  ---------------------------
  
  在 Sling Model 中计算属性值:
  
  @Model(adaptables = {SlingHttpServletRequest.class, Resource.class})
  public interface HeroModel {
      
      @Inject
      private Resource resource;
      
      default String getHtmlTagClass() {
          return "hero-section " + getVariantClass();
      }
      
      default String getVariantClass() {
          String variant = resource.getValueMap().get("variant", "default");
          return "hero--" + variant;
      }
      
      default String getHtmlAttributes() {
          Map<String, String> attrs = new HashMap<>();
          attrs.put("data-variant", getVariant());
          attrs.put("data-component", "hero");
          return attrs.entrySet().stream()
              .map(e -> e.getKey() + "=\"" + e.getValue() + "\"")
              .collect(Collectors.joining(" "));
      }
  }
  
  在 HTL 中使用:
  
  <sly data-sly-use.model="com.example.models.HeroModel"></sly>
  <section data-sly-attribute.class="${model.htmlTagClass}">
      <!-- 内容 -->
  </section>
-->

<!--
  7. 最佳实践
  ==========
-->

<!--
  7.1 HTML 标签选择
  ----------------
  
  选择原则:
  
  1. 使用语义化标签
     - section: 章节区域
     - article: 独立内容
     - nav: 导航
     - header/footer: 页头/页脚
     - main: 主要内容
     - aside: 侧边栏
     - div: 通用容器（无特定语义时）
  
  2. 符合 HTML5 标准
     - 使用有效的 HTML5 标签
     - 遵循 HTML5 语义规范
     - 避免使用废弃的标签
  
  3. 考虑可访问性
     - 使用语义化标签
     - 必要时添加 ARIA 属性
     - 遵循 WCAG 标准
-->

<!--
  7.2 类名命名规范
  --------------
  
  命名建议:
  
  1. BEM 命名法
     - Block: 组件名称（hero）
     - Element: 元素名称（hero__title）
     - Modifier: 修饰符（hero--large）
     - 示例: hero, hero__title, hero--large
  
  2. 语义化命名
     - 使用有意义的名称
     - 避免缩写（除非通用）
     - 使用连字符分隔（kebab-case）
  
  3. 一致性
     - 保持项目内命名一致
     - 遵循团队约定
     - 使用一致的命名模式
-->

<!--
  7.3 ID 使用建议
  -------------
  
  ID 使用原则:
  
  1. 避免静态 ID
     - 组件可能有多个实例
     - 静态 ID 会导致冲突
     - 使用动态 ID（component.id）
  
  2. 必要时使用
     - 锚点链接
     - JavaScript 选择器（如果必须）
     - 表单关联（label for）
  
  3. 优先级
     - 优先使用类名选择器
     - 必要时使用 data 属性
     - ID 作为最后选择
-->

<!--
  8. 调试和故障排查
  =================
-->

<!--
  8.1 配置不生效
  -------------
  
  问题: HTML 标签配置没有应用
  
  检查项:
  1. 文件位置
     - 路径: /apps/{project}/components/{component}/_cq_htmlTag/.content.xml
     - 文件名和文件夹名正确
     - 文件存在且可读
  
  2. XML 语法
     - XML 格式正确
     - 命名空间声明正确
     - 节点类型正确
  
  3. 属性名
     - 属性名正确（tagName, class, id 等）
     - 属性值格式正确
     - 没有拼写错误
  
  4. 缓存
     - 清除浏览器缓存
     - 重启 AEM 实例
     - 清除 JCR 缓存
  
  5. 组件渲染
     - 确认组件正在渲染
     - 检查 HTML 输出
     - 查看浏览器开发者工具
-->

<!--
  8.2 属性冲突
  -----------
  
  问题: 配置的属性与 HTL 模板中的属性冲突
  
  说明:
  - HTL 模板中的属性会覆盖配置
  - 如果两者都设置了相同属性，HTL 优先
  - 建议在配置中设置静态属性
  - 在 HTL 中设置动态属性
  
  解决方案:
  1. 统一管理
     - 静态属性在配置中
     - 动态属性在 HTL 中
     - 避免重复设置
  
  2. 合并属性
     - 在 HTL 中合并配置和动态属性
     - 使用 component.cssClassNames
     - 合理组合
-->

<!--
  8.3 调试工具
  -----------
  
  1. 浏览器开发者工具
     - 查看 HTML 输出
     - 检查元素属性
     - 验证标签和类名
     - 使用元素检查器
  
  2. CRX/DE Lite
     - 查看配置文件
     - 检查属性值
     - 验证节点结构
     - 路径: http://localhost:4502/crx/de/index.jsp
  
  3. 日志
     - 启用 DEBUG 日志级别
     - 查看组件渲染日志
     - 检查配置加载日志
     - 日志器: com.day.cq.wcm.core.components
  
  4. HTML 输出检查
     - 查看页面源代码
     - 检查实际输出的 HTML
     - 验证属性是否正确应用
-->

<!--
  9. 版本兼容性
  =============
-->

<!--
  AEM 6.0+
  - 基本 HTML 标签配置支持
  - _cq_htmlTag 文件夹支持
  - tagName, class, id 等属性
  
  AEM 6.1+
  - 改进的 HTML 标签处理
  - 更好的属性支持
  
  AEM 6.2+
  - 增强的 HTML 标签功能
  - 改进的属性合并
  
  AEM 6.3+ (Touch UI)
  - 全面支持 Touch UI
  - 改进的 HTML 输出
  - 更好的语义化支持
  
  AEM 6.4+
  - 性能优化
  - 改进的 HTML 标签处理
  
  AEM 6.5+
  - 增强的 HTML 标签功能
  - 改进的语义化支持
  
  AEM as a Cloud Service
  - 所有功能都支持
  - 性能优化
  - 更好的云原生支持
-->

<!--
  10. 与 Core Components 的关系
  ============================
-->

<!--
  10.1 Core Components 的 HTML 标签使用
  -----------------------------------
  
  Core Components 的 HTML 标签使用:
  
  1. 语义化标签
     - 广泛使用语义化 HTML5 标签
     - section, article, nav 等
     - 符合现代 Web 标准
  
  2. 可访问性
     - 使用 ARIA 属性
     - 遵循 WCAG 标准
     - 改善屏幕阅读器支持
  
  3. 参考实现
     - 可以参考 Core Components 的实现
     - 学习 HTML 标签使用模式
     - 遵循 AEM 最佳实践
-->

<!--
  10.2 迁移建议
  ------------
  
  如果要迁移到 Core Components:
  
  1. 评估 HTML 标签需求
     - 检查当前使用的标签
     - 评估是否需要自定义
     - Core Components 可能已提供合适的标签
  
  2. 标签适配
     - 将自定义标签适配到 Core Components
     - 保持语义化
     - 确保可访问性
  
  3. 测试验证
     - 测试 HTML 输出
     - 验证样式是否正常
     - 检查可访问性
-->

<!--
  12. 编程方式操作 HTML 标签配置
  =============================
-->

<!--
  12.1 读取 HTML 标签配置
  ---------------------
  
  通过 Java 代码读取配置:
  
  public Resource getHtmlTagConfig(Resource componentResource) {
      return componentResource.getChild("_cq_htmlTag");
  }
  
  public String getTagName(Resource componentResource) {
      Resource htmlTagConfig = getHtmlTagConfig(componentResource);
      if (htmlTagConfig != null) {
          return htmlTagConfig.getValueMap().get("tagName", "div");
      }
      return "div";  // 默认值
  }
  
  public String getCssClass(Resource componentResource) {
      Resource htmlTagConfig = getHtmlTagConfig(componentResource);
      if (htmlTagConfig != null) {
          return htmlTagConfig.getValueMap().get("class", "");
      }
      return "";
  }
  
  使用示例:
  
  Resource componentResource = resolver.resolve("/apps/myapp/components/hero");
  String tagName = getTagName(componentResource);  // "section"
  String cssClass = getCssClass(componentResource);  // "hero-section"
-->

<!--
  12.2 动态创建 HTML 标签配置
  -------------------------
  
  程序化创建配置:
  
  public Resource createHtmlTagConfig(Resource componentResource, String tagName, String cssClass) {
      ResourceResolver resolver = componentResource.getResourceResolver();
      
      try {
          Resource htmlTagConfig = componentResource.getChild("_cq_htmlTag");
          
          if (htmlTagConfig == null) {
              // 创建配置节点
              Map<String, Object> props = new HashMap<>();
              props.put("jcr:primaryType", "nt:unstructured");
              htmlTagConfig = resolver.create(componentResource, "_cq_htmlTag", props);
          }
          
          ModifiableValueMap props = htmlTagConfig.adaptTo(ModifiableValueMap.class);
          props.put("tagName", tagName);
          
          if (cssClass != null && !cssClass.isEmpty()) {
              props.put("class", cssClass);
          }
          
          resolver.commit();
          return htmlTagConfig;
      } catch (PersistenceException e) {
          log.error("Error creating HTML tag config", e);
          return null;
      }
  }
-->

<!--
  12.3 Sling Model 中使用 HTML 标签配置
  -----------------------------------
  
  在 Sling Model 中访问配置:
  
  @Model(adaptables = {SlingHttpServletRequest.class, Resource.class})
  public interface ComponentHtmlTag {
      
      @Inject
      private Resource resource;
      
      default String getTagName() {
          String resourceType = resource.getResourceType();
          Resource componentResource = resource.getResourceResolver()
              .resolve("/apps/" + resourceType);
          
          if (componentResource != null) {
              Resource htmlTagConfig = componentResource.getChild("_cq_htmlTag");
              if (htmlTagConfig != null) {
                  return htmlTagConfig.getValueMap().get("tagName", "div");
              }
          }
          
          return "div";
      }
      
      default String getHtmlAttributes() {
          // 构建 HTML 属性字符串
          // ...
      }
  }
  
  在 HTL 中使用:
  
  <sly data-sly-use.htmlTag="com.example.models.ComponentHtmlTag"></sly>
  <${htmlTag.tagName} class="${htmlTag.cssClass}">
      <!-- 内容 -->
  </${htmlTag.tagName}>
-->

<!--
  13. HTML 标签配置的查找机制
  ===========================
-->

<!--
  13.1 查找顺序
  -----------
  
  AEM 查找 HTML 标签配置的顺序:
  
  1. 当前组件的配置
     - 路径: /apps/{project}/components/{component}/_cq_htmlTag
     - 优先级: 最高
  
  2. 通过 resourceSuperType 继承
     - 路径: /apps/{project}/components/{super-component}/_cq_htmlTag
     - 优先级: 中（递归查找）
  
  3. 系统默认
     - 如果没有配置，使用 <div> 标签
     - 优先级: 低
  
  注意:
  - 配置不会合并，只使用第一个找到的
  - 子组件配置会覆盖父组件配置
  - 不支持多配置继承合并
-->

<!--
  13.2 Resource Resolution 集成
  ----------------------------
  
  配置查找使用 Sling Resource Resolution:
  
  public Resource findHtmlTagConfig(Resource componentResource) {
      Resource htmlTagConfig = componentResource.getChild("_cq_htmlTag");
      if (htmlTagConfig != null) {
          return htmlTagConfig;
      }
      
      // 检查 resourceSuperType
      String superType = componentResource.getValueMap()
          .get("sling:resourceSuperType", String.class);
      if (superType != null) {
          Resource superComponent = resourceResolver.resolve("/apps/" + superType);
          if (superComponent != null) {
              return findHtmlTagConfig(superComponent);  // 递归查找
          }
      }
      
      return null;  // 使用默认值
  }
-->

<!--
  14. 高级应用场景
  ==============
-->

<!--
  14.1 响应式类名
  -------------
  
  在 HTL 中结合响应式类名:
  
  hero.html:
  <section data-sly-attribute.class="${'hero-section ' + component.cssClassNames + ' ' + properties.variant}"
           data-sly-set.responsiveClasses="${'hero-mobile ' + properties.showOnMobile ? 'hero-visible' : 'hero-hidden'}"
           data-sly-attribute.class="${responsiveClasses}">
      <!-- 内容 -->
  </section>
  
  _cq_htmlTag/.content.xml:
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section"/>
  
  说明:
  - 配置提供基础类名
  - HTL 添加响应式和动态类名
  - 两者结合使用
-->

<!--
  14.2 主题和变体
  -------------
  
  支持主题和变体:
  
  _cq_htmlTag/.content.xml:
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="section"
            class="hero-section"
            data-theme="default"/>
  
  hero.html:
  <section data-sly-attribute.class="${'hero-section hero--' + properties.theme + ' ' + component.cssClassNames}"
           data-sly-attribute.data-theme="${properties.theme}"
           data-sly-attribute.data-variant="${properties.variant}">
      <!-- 内容 -->
  </section>
  
  说明:
  - 配置提供基础结构和默认主题
  - HTL 根据组件属性添加主题和变体类名
  - 使用 data 属性标记主题和变体
-->

<!--
  14.3 微数据（Microdata）支持
  --------------------------
  
  添加微数据标记:
  
  _cq_htmlTag/.content.xml:
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="article"
            itemscope=""
            itemtype="http://schema.org/Article"/>
  
  或者使用 HTL 动态设置:
  
  article.html:
  <article data-sly-attribute.itemscope="${properties.enableMicrodata ? '' : null}"
           data-sly-attribute.itemtype="${properties.itemType}"
           data-sly-attribute.class="${component.cssClassNames}">
      <h1 itemprop="headline">${properties.title}</h1>
      <div itemprop="articleBody">${properties.content @ context='html'}</div>
  </article>
  
  说明:
  - 支持 Schema.org 微数据
  - 可以静态配置或动态设置
  - 有助于 SEO
-->

<!--
  14.4 JSON-LD 集成
  ---------------
  
  虽然 JSON-LD 通常不在 HTML 标签配置中，但可以配合使用:
  
  hero.html:
  <section class="hero-section" data-component="hero">
      <!-- 内容 -->
      <script type="application/ld+json">
      {
          "@context": "https://schema.org",
          "@type": "WebPageElement",
          "name": "${properties.title}"
      }
      </script>
  </section>
  
  说明:
  - JSON-LD 通常放在组件内容中
  - HTML 标签配置提供包装元素
  - 两者配合使用实现结构化数据
-->

<!--
  15. 性能优化
  ===========
-->

<!--
  15.1 配置缓存
  -----------
  
  HTML 标签配置会被缓存:
  
  1. JCR 节点缓存
     - 配置节点会被 JCR 缓存
     - 减少重复读取
     - 提高性能
  
  2. 组件解析缓存
     - 组件配置会被解析缓存
     - 避免重复解析
     - 优化查找性能
  
  3. 缓存失效
     - 配置变更需要清除缓存
     - 重启 AEM 实例
     - 或使用缓存刷新机制
-->

<!--
  15.2 属性优化
  -----------
  
  优化建议:
  
  1. 避免过度配置
     - 只配置必要的属性
     - 避免冗余属性
     - 保持配置简洁
  
  2. 合理使用类名
     - 避免过长的类名列表
     - 使用有意义的类名
     - 考虑 CSS 选择器性能
  
  3. 减少动态属性
     - 静态属性放在配置中
     - 动态属性在 HTL 中设置
     - 平衡配置和灵活性
-->

<!--
  16. 测试策略
  ===========
-->

<!--
  16.1 单元测试
  -----------
  
  测试 HTML 标签配置读取:
  
  @ExtendWith(AemContextExtension.class)
  class HtmlTagConfigTest {
      
      @RegisterExtension
      AemContext context = new AemContext();
      
      @Test
      void testHtmlTagConfigLoading() {
          // 创建配置
          context.create().resource("/apps/myapp/components/hero/_cq_htmlTag",
              "jcr:primaryType", "nt:unstructured",
              "tagName", "section",
              "class", "hero-section");
          
          // 获取配置
          Resource componentResource = context.resourceResolver()
              .resolve("/apps/myapp/components/hero");
          Resource htmlTagConfig = componentResource.getChild("_cq_htmlTag");
          
          assertNotNull("HTML tag config should exist", htmlTagConfig);
          
          ValueMap props = htmlTagConfig.getValueMap();
          assertEquals("section", props.get("tagName", String.class));
          assertEquals("hero-section", props.get("class", String.class));
      }
  }
-->

<!--
  16.2 集成测试
  -----------
  
  测试 HTML 输出:
  
  @ExtendWith(AemContextExtension.class)
  class HtmlTagOutputTest {
      
      @RegisterExtension
      AemContext context = new AemContext();
      
      @Test
      void testHtmlOutput() {
          // 创建组件和配置
          context.create().resource("/apps/myapp/components/hero",
              "jcr:primaryType", "cq:Component");
          context.create().resource("/apps/myapp/components/hero/_cq_htmlTag",
              "jcr:primaryType", "nt:unstructured",
              "tagName", "section",
              "class", "hero-section");
          
          // 创建组件实例
          context.create().resource("/content/test/jcr:content/hero",
              "jcr:primaryType", "nt:unstructured",
              "sling:resourceType", "myapp/components/hero");
          
          // 渲染组件（需要实际的渲染服务）
          // 验证 HTML 输出包含正确的标签和属性
      }
  }
-->

<!--
  16.3 浏览器测试
  -------------
  
  使用浏览器工具测试:
  
  1. 查看页面源代码
     - 检查实际的 HTML 输出
     - 验证标签和属性
     - 确认配置生效
  
  2. 使用开发者工具
     - 检查元素属性
     - 验证类名
     - 测试 CSS 选择器
  
  3. 自动化测试
     - 使用 Selenium 或 Cypress
     - 验证 HTML 结构
     - 检查属性值
-->

<!--
  17. 安全考虑
  ===========
-->

<!--
  17.1 XSS 防护
  -----------
  
  HTML 标签配置中的值应该是安全的:
  
  1. 静态配置
     - 配置中的值通常是静态的
     - 不需要 XSS 防护
     - 但应该验证值
  
  2. 动态属性
     - 如果属性值来自用户输入，需要转义
     - 使用 HTL 的自动转义
     - 避免在配置中直接使用用户输入
  
  3. 属性值验证
     - 验证标签名有效性
     - 验证属性名有效性
     - 避免恶意属性
-->

<!--
  17.2 属性值验证
  -------------
  
  验证配置值:
  
  public boolean validateHtmlTagConfig(Resource htmlTagConfig) {
      if (htmlTagConfig == null) {
          return true;  // 无配置是有效的
      }
      
      ValueMap props = htmlTagConfig.getValueMap();
      
      // 验证标签名
      String tagName = props.get("tagName", String.class);
      if (tagName != null && !isValidHtmlTag(tagName)) {
          return false;
      }
      
      // 验证类名
      String cssClass = props.get("class", String.class);
      if (cssClass != null && containsXss(cssClass)) {
          return false;
      }
      
      return true;
  }
  
  private boolean isValidHtmlTag(String tagName) {
      // 白名单验证
      Set<String> validTags = Set.of("div", "section", "article", "nav", 
                                      "header", "footer", "aside", "main");
      return validTags.contains(tagName.toLowerCase());
  }
-->

<!--
  18. 可访问性（Accessibility）
  ============================
-->

<!--
  18.1 ARIA 属性最佳实践
  ---------------------
  
  使用 ARIA 属性改善可访问性:
  
  _cq_htmlTag/.content.xml:
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="nav"
            role="navigation"
            aria-label="Main Navigation"/>
  
  或者使用 HTL 动态设置:
  
  nav.html:
  <nav data-sly-attribute.role="${properties.role}"
       data-sly-attribute.aria-label="${properties.ariaLabel}"
       data-sly-attribute.aria-labelledby="${properties.ariaLabelledBy}">
      <!-- 内容 -->
  </nav>
  
  说明:
  - 使用语义化标签减少 ARIA 需求
  - 在必要时添加 ARIA 属性
  - 遵循 WCAG 标准
-->

<!--
  18.2 语义化 HTML
  --------------
  
  使用语义化标签:
  
  1. 选择合适的标签
     - section: 章节
     - article: 独立内容
     - nav: 导航
     - header/footer: 页头/页脚
     - main: 主要内容
     - aside: 侧边栏
  
  2. 避免过度使用 div
     - 优先使用语义化标签
     - div 作为最后选择
     - 保持 HTML 结构清晰
  
  3. 结合 ARIA
     - 语义化标签不足时使用 ARIA
     - 改善屏幕阅读器体验
     - 符合无障碍标准
-->

<!--
  19. SEO 优化
  ===========
-->

<!--
  19.1 语义化标记
  -------------
  
  使用语义化 HTML 有助于 SEO:
  
  _cq_htmlTag/.content.xml:
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="article"
            itemscope=""
            itemtype="http://schema.org/Article"/>
  
  说明:
  - 语义化标签帮助搜索引擎理解内容
  - 使用合适的标签表示内容类型
  - 结合微数据提供结构化信息
-->

<!--
  19.2 结构化数据
  -------------
  
  添加结构化数据标记:
  
  article.html:
  <article itemscope itemtype="http://schema.org/Article"
           class="article-component">
      <h1 itemprop="headline">${properties.title}</h1>
      <div itemprop="articleBody">
          ${properties.content @ context='html'}
      </div>
      <meta itemprop="datePublished" content="${properties.publishDate}"/>
  </article>
  
  说明:
  - 使用 Schema.org 微数据
  - 提供结构化信息
  - 改善搜索引擎理解
-->

<!--
  20. 国际化考虑
  =============
-->

<!--
  20.1 语言属性
  -----------
  
  设置语言属性:
  
  _cq_htmlTag/.content.xml:
  <jcr:root jcr:primaryType="nt:unstructured"
            tagName="article"
            lang="en"/>
  
  或者在 HTL 中动态设置:
  
  article.html:
  <article data-sly-attribute.lang="${currentPage.language}"
           data-sly-attribute.class="${component.cssClassNames}">
      <!-- 内容 -->
  </article>
  
  说明:
  - lang 属性指定内容语言
  - 可以静态配置或动态设置
  - 有助于可访问性和 SEO
-->

<!--
  21. 版本控制和部署
  ================
-->

<!--
  21.1 版本控制策略
  ---------------
  
  HTML 标签配置应该纳入版本控制:
  
  1. 文件跟踪
     - 配置文件纳入 Git
     - 跟踪配置变更
     - 记录变更历史
  
  2. 变更管理
     - 使用有意义的提交消息
     - 记录变更原因
     - 标记重大变更
  
  3. 测试验证
     - 测试配置变更影响
     - 验证 HTML 输出
     - 检查样式影响
-->

<!--
  21.2 部署最佳实践
  ----------------
  
  1. 打包策略
     - 将配置包含在组件包中
     - 使用 Maven 或 Gradle 构建
     - 创建可安装的包
  
  2. 部署顺序
     - 先部署组件定义
     - 再部署 HTML 标签配置
     - 最后部署模板和脚本
  
  3. 回滚策略
     - 保留旧版本配置
     - 准备回滚脚本
     - 测试回滚流程
-->

<!--
  22. 常见问题和解决方案
  ====================
-->

<!--
  22.1 配置不生效
  -------------
  
  问题: HTML 标签配置没有应用
  
  解决方案:
  1. 检查文件路径
     - 确认路径正确
     - 检查文件名拼写
     - 验证文件存在
  
  2. 验证 XML 语法
     - 检查 XML 格式
     - 验证命名空间
     - 检查节点类型
  
  3. 清除缓存
     - 清除浏览器缓存
     - 重启 AEM 实例
     - 清除 JCR 缓存
  
  4. 检查组件渲染
     - 确认组件正在渲染
     - 查看 HTML 输出
     - 使用开发者工具检查
-->

<!--
  22.2 属性冲突
  -----------
  
  问题: 配置的属性与 HTL 模板中的属性冲突
  
  说明:
  - HTL 模板中的属性会覆盖配置
  - 这是正常行为
  - 需要协调配置和模板
  
  解决方案:
  1. 统一管理
     - 静态属性在配置中
     - 动态属性在 HTL 中
     - 避免重复设置
  
  2. 合并属性
     - 在 HTL 中合并配置和动态属性
     - 使用 component.cssClassNames
     - 合理组合
-->

<!--
  22.3 类名重复
  -----------
  
  问题: 类名重复或不一致
  
  解决方案:
  1. 统一命名规范
     - 使用一致的命名模式
     - 遵循 BEM 或其他规范
     - 保持项目内一致
  
  2. 类名管理
     - 基础类名在配置中
     - 变体类名在 HTL 中
     - 避免重复定义
  
  3. 使用工具
     - 使用 CSS 预处理器管理类名
     - 使用构建工具检查重复
     - 代码审查检查一致性
-->

<!--
  23. 最佳实践总结
  ==============
-->

<!--
  23.1 配置原则
  -----------
  
  1. 简洁明了
     - 只配置必要的属性
     - 保持配置清晰
     - 避免过度配置
  
  2. 语义化优先
     - 使用语义化 HTML 标签
     - 符合 HTML5 标准
     - 改善可访问性和 SEO
  
  3. 合理分工
     - 静态属性在配置中
     - 动态属性在 HTL 中
     - 两者协调使用
  
  4. 一致性
     - 保持项目内一致
     - 遵循团队规范
     - 使用统一的命名模式
-->

<!--
  23.2 使用检查清单
  ---------------
  
  开发时检查:
  ✓ 配置文件位置正确
  ✓ XML 语法正确
  ✓ 标签名有效
  ✓ 属性名正确
  ✓ 类名命名规范
  ✓ 语义化标签使用
  ✓ ARIA 属性（如需要）
  ✓ 测试 HTML 输出
  ✓ 验证样式正常
  ✓ 检查可访问性
  
  部署前检查:
  ✓ 配置文件在版本控制中
  ✓ 所有环境配置一致
  ✓ 性能测试通过
  ✓ 可访问性检查通过
  ✓ 文档完整
-->

<!--
  24. 相关文档
  ==========
  
  - 组件结构: 01-component-structure.html
  - 组件配置: 04-component-content-xml.html
  - 组件模板（HTL）: 05-component-htl-template.html
  - 编辑配置: 06-component-edit-config.html
  - 组件模板: 07-component-template.html
  - 高级主题: 04-advanced/
  - Core Components: https://github.com/adobe/aem-core-wcm-components
  - AEM 官方文档: https://experienceleague.adobe.com/docs/experience-manager.html
  - HTML5 规范: https://html.spec.whatwg.org/
  - WCAG 指南: https://www.w3.org/WAI/WCAG21/quickref/
-->

